package com.mindforger.coachingnotebook.server.store.gae;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.jdo.PersistenceManager;
import javax.jdo.Query;

import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.KeyFactory;
import com.google.appengine.api.datastore.Text;
import com.mindforger.coachingnotebook.client.ui.security.MindForgerSecurityException;
import com.mindforger.coachingnotebook.server.QuestionsRepository;
import com.mindforger.coachingnotebook.server.Utils;
import com.mindforger.coachingnotebook.server.email.EmailBean;
import com.mindforger.coachingnotebook.server.email.Emailing;
import com.mindforger.coachingnotebook.server.i10n.Messages;
import com.mindforger.coachingnotebook.server.store.Persistence;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeCheckListAnswerBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeCommentBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeFriendBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeGrowBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeLifeVisionBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaePermissionBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeQuestionAnswerBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeQuestionBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeUserBean;
import com.mindforger.coachingnotebook.server.store.gae.beans.GaeUserSettingsBean;
import com.mindforger.coachingnotebook.shared.MindForgerResourceType;
import com.mindforger.coachingnotebook.shared.beans.CheckListAnswerBean;
import com.mindforger.coachingnotebook.shared.beans.CommentBean;
import com.mindforger.coachingnotebook.shared.beans.DescriptorBean;
import com.mindforger.coachingnotebook.shared.beans.FriendBean;
import com.mindforger.coachingnotebook.shared.beans.GrowBean;
import com.mindforger.coachingnotebook.shared.beans.LabelBean;
import com.mindforger.coachingnotebook.shared.beans.PermissionBean;
import com.mindforger.coachingnotebook.shared.beans.QuestionAnswerBean;
import com.mindforger.coachingnotebook.shared.beans.QuestionSetsBean;
import com.mindforger.coachingnotebook.shared.beans.RiaBootImageBean;
import com.mindforger.coachingnotebook.shared.beans.UserBean;
import com.mindforger.coachingnotebook.shared.beans.UserProfileBean;
import com.mindforger.coachingnotebook.shared.beans.UserSettingsBean;

/**
 * Google AppEngine bigtable based persistence.
 */
/*
 * Conventions:
 *  - use delete by query
 *  - each method must have security documentation explaining how it is secured
 *  - TODO each method must have limits documentation (where applicable): number of entities & fields length
 *  - use prepared statements (injection protection)
 *  - use parameters in prepared statements (injection protection)
 *  - every call to store should logged (query, makePersistent, deletePersistent)
 * 
 * Remarks:
 *  - GAE persistence beans...
 *     > use Keys where possible (not String), fieldKey vs. fieldId (user service ID)
 *  - PM can be used for single transactions i.e. multiple queries, reads and writes can be done
 *    using the same PM, but think about it as a single TX. The important thing is that all the 
 *    objects must be of the same type (in my case).
 *  - security: every call must cope with permissions and security
 *     > all saves must be made by owner
 *     > all gets must be made by owner or user with sufficient privileges (if it is done by getting 
 *       user ID from the system, then just document it)
 *     > every method must have JavaDoc with security section and explanation why it is secure
 *     > prepared statements must be used
 *     > parameters in prepared statements must be used to ensure their proper quoting TODO
 *  - limits: every call must cope with limits for given user
 *     > persistence must check and enforce the limits and throw exceptions on violation
 *     > RIA may check limits as well, but just for user convenience to let her/him know soon enough
 *  - prepared statements
 *     > all the code should be (re)written to use prepared statements to avoid injection
 *     > actually only statements that use parameters that are not generated by me must be rewritten
 *     
 * Goodies:
 *  - PM can be reused only for the operations on the same entity group i.e. GAE bean
 *  - if the object is not detached, all the changes are propagated to it until PM is closed
 *  - delete by query:
 * 		Query q = pm.newQuery(Book.class); 
 * 		q.deletePersistentAll(); 
 *  - transactions (http://db.apache.org/jdo/pm.html)
 *    http://code.google.com/appengine/docs/java/datastore/transactions.html#What_Can_Be_Done_In_a_Transaction
 *    
 *    Transaction tx = pm.currentTransaction();
 *    try {
 *    	  tx.begin();
 *        ...
 *		  tx.commit();
 *    }
 *    catch (Exception e) {
 *        handlePmPersistenceException(e);
 *    }
 *    finally {
 *        // hadlePmPersistenceFinally(tx);
 *        if (tx.isActive()) {
 *         	  // error occurred so rollback the transaction
 *             tx.rollback();
 *         }
 *   }
 *   pm.close();
 *    
 * Improvements:
 *  - use own security cache OR MemCache for the optimization of security checks and queries:
 */
public class GaePersistence extends GaePersistenceAdmin implements Persistence {
	private static final Logger LOG=Logger.getLogger("GaePersistence");
		
	public GaePersistence() {
		super();
	}	
	
	/*
	 * Security: 
	 *   this method assembles result using other methods that do all the checks
	 * Limits:
	 *   N/A
	 */
	public RiaBootImageBean getRiaBootImage(String userId, String nickname, String email) {
		RiaBootImageBean result=new RiaBootImageBean();
		result.setUser(loginCheck(userId, nickname, email));
		result.setAccountLimits(getUserLimits(userId));
		result.setGrowBeans(getGrows(userId));
		result.setUserSettings(getUserSettings(userId));
		result.setQuestionSetsBean(questionsRepository.toQuestionSetsBean());
		return result;
	}
	
	/*
	 * Security: 
	 *   userId set by trusted code + used to get the object
	 * Limits:
	 *   N/A
	 */
	public UserSettingsBean getUserSettings(String userId) {
		LOG.log(Level.INFO,"getUserSettings()");
		UserSettingsBean result;
		PersistenceManager pm = getPm();
		try {			
			Query query = pm.newQuery(GaeUserSettingsBean.class);
			query.setFilter("ownerId == userId");
			query.declareParameters("String userId");
			LOG.log(Level.INFO, "Query: "+query);
			@SuppressWarnings("unchecked")
			List<GaeUserSettingsBean> usersSettingsList = (List<GaeUserSettingsBean>)query.execute(userId);
			LOG.log(Level.INFO,"  Result: "+usersSettingsList.size());
			GaeUserSettingsBean gaeUserSettingsBean;
			if(usersSettingsList!=null && usersSettingsList.size()>0) {
				gaeUserSettingsBean=usersSettingsList.get(0);
			} else {
				gaeUserSettingsBean=new GaeUserSettingsBean();
			}
			result=gaeUserSettingsBean.toPojo();
		} finally {
			pm.close();
		}
		
		return result;
	}

	/*
	 * Security: 
	 *   userId set by trusted code + used to get the object
	 * Limits:
	 *   N/A
	 */
	public void saveUserSettings(String userId, UserSettingsBean userSettings) {		
		PersistenceManager pm = getPm();
		try {
			Query query = pm.newQuery(GaeUserSettingsBean.class);
			query.setFilter("ownerId == userId");
			query.declareParameters("String userId");
			LOG.log(Level.INFO,"Query: "+query);			
			@SuppressWarnings("unchecked")
			List<GaeUserSettingsBean> usersSettingsList=(List<GaeUserSettingsBean>)query.execute(userId);
			LOG.log(Level.INFO,"  Result: "+usersSettingsList.size());
			GaeUserSettingsBean gaeUserSettingsBean;
			if(usersSettingsList!=null && usersSettingsList.size()>0) {
				gaeUserSettingsBean=usersSettingsList.get(0);
			} else {
				gaeUserSettingsBean=new GaeUserSettingsBean();
			}
			gaeUserSettingsBean.fromPojo(userSettings);
			gaeUserSettingsBean.setOwnerId(userId);
			
			pm.makePersistent(gaeUserSettingsBean);
			countCache.remove(GaeUserSettingsBean.class);
		} finally {
			pm.close();
		}
	}

	/*
	 * Security: 
	 *   userId is used to filter grows by owner
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public GrowBean[] getGrows(String userId) {
		LOG.log(Level.INFO,"getGrows()");
		List<GaeGrowBean> gaeResult=null;
		PersistenceManager pm = getPm();
		try {
			Query query = pm.newQuery(GaeGrowBean.class);
			query.setFilter("ownerId == userId");
			query.declareParameters("String userId");
			LOG.log(Level.INFO,"Query: "+query);
			gaeResult = (List<GaeGrowBean>)query.execute(userId);
			LOG.log(Level.INFO,"  Result: "+gaeResult.size());						
		} finally {
			pm.close();
		}
		
		if (gaeResult==null || gaeResult.isEmpty()) {
			return new GrowBean[0];
		} else {
			// sort by date (the first is the one which was modified last
			Collections.sort(gaeResult, gaeGrowModifiedComparator);			
			GrowBean[] result=new GrowBean[gaeResult.size()];
			for (int i = 0; i < result.length; i++) {
				result[i]=gaeResult.get(i).toPojo();
			}			
			return result;
		}									
	}

	/* 
	 * Security: 
	 *   permissions for grow checked (non-owners may call this method in case of sharing)
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public GrowBean getGrow(String key, String userId) {
		LOG.info("getGrow() "+key);
		GrowBean result;
		PersistenceManager pm = getPm();
		try {
			result = hasPermissionGrow(key, userId, pm);
			result.setModifiedPretty(Utils.getPrettyTimestampHtml(result.getModified().getTime()));
			Query query = pm.newQuery(GaeQuestionAnswerBean.class);
			query.setFilter("growKey == key");
			query.declareParameters("String key");
			LOG.info("Query: "+query);
			List<GaeQuestionAnswerBean> oldQuestions=(List<GaeQuestionAnswerBean>)query.execute(key);
			if(!oldQuestions.isEmpty()) {
				for (int i = 0; i < oldQuestions.size(); i++) {
					GaeQuestionAnswerBean gaeQuestionBean = oldQuestions.get(i);
					if(QuestionAnswerBean.G_PART.equals(gaeQuestionBean.getGrowType())) {
						result.getG().getQuestions().add(gaeQuestionBean.toPojo());
					} else {
						if(QuestionAnswerBean.R_PART.equals(gaeQuestionBean.getGrowType())) {
							result.getR().getQuestions().add(gaeQuestionBean.toPojo());
						} else {
							if(QuestionAnswerBean.O_PART.equals(gaeQuestionBean.getGrowType())) {
								result.getO().getQuestions().add(gaeQuestionBean.toPojo());
							} else {
								if(QuestionAnswerBean.W_PART.equals(gaeQuestionBean.getGrowType())) {
									result.getW().getQuestions().add(gaeQuestionBean.toPojo());
								} else {
									if(QuestionAnswerBean.I_PART.equals(gaeQuestionBean.getGrowType())) {
										result.getI().getQuestions().add(gaeQuestionBean.toPojo());
									} else {
										LOG.severe("Error: skipping question with unknown GROW type - "+gaeQuestionBean.getGrowType()+" / "+gaeQuestionBean.getKey());
									}
								}
							}
						}
					}
				}
			}
		} finally {
			pm.close();
		}
		return result;
	}
		
	/*
	 * Security: 
	 *   userId set by trusted code, growOwner is determined first and checked against userId
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	/*
		 * TODO
		 * TODO
		 * TODO
		 * TODO
		 * TODO
		 * TODO
		 *
		userKeysWhoHadPermission is entirely wrong:
	     - save old permissions: user and permission (number)
		 - send email if the number is > or < (shared or unshared)
		 - no entry equals 0
    */	
	public void setGrowAcl(String userId, String growId, PermissionBean[] acl) {
		if(growId==null) {
			throw new RuntimeException("ACL cannot be set for GROW ID null!");
		}		
		// security: user must be owner
		checkGrowOwnership(userId, growId);
		
		// delete existing ACL
		Map<String, Integer> userKeysWhoHadPermission=new HashMap<String, Integer>();
		List<GaePermissionBean> oldPermissions=null;
		PersistenceManager pm=getPm();
		try {
			Query query=pm.newQuery(GaePermissionBean.class);
			query.declareParameters("String growId");
			query.setFilter("subjectKey == growId");
			LOG.log(Level.INFO,"Query: "+query);
			oldPermissions = (List<GaePermissionBean>)query.execute(growId);
			List<GaePermissionBean> gaePermissionsToDelete=new ArrayList<GaePermissionBean>();
			if(!oldPermissions.isEmpty()) {
				for (int i = 0; i < oldPermissions.size(); i++) {
					gaePermissionsToDelete.add(oldPermissions.get(i));
					if(oldPermissions.get(i).getPermission()>PermissionBean.PERMISSION_NO) {
						userKeysWhoHadPermission.put(oldPermissions.get(i).getUserKey(), oldPermissions.get(i).getPermission());						
					}
				}
			}
			// delete using query cannot be used - need to know who to email
			pm.deletePersistentAll(gaePermissionsToDelete);
			countCache.remove(GaePermissionBean.class);
		} finally {
			pm.close();
		}
		
		// create new ACL
		Key userKey=null;
		if(acl==null || acl.length==0) {
			return;
		} else {
			Set<Key> userKeysToEmail=new HashSet<Key>();
			List<GaePermissionBean> newAcl=new ArrayList<GaePermissionBean>();
			for (int i = 0; i < acl.length; i++) {
				if(acl[i].getPermission()>PermissionBean.PERMISSION_NO) {
					GaePermissionBean gaePermissionBean = new GaePermissionBean();
					userKey = getKeyForUserId(acl[i].getUser().getUserId());
					// send mail to users who didn't have permission in the past
					if(!userKeysWhoHadPermission.containsKey(Utils.keyToString(userKey))) {
						userKeysToEmail.add(userKey);
					}
					gaePermissionBean.fromPojo(acl[i],Utils.keyToString(userKey));
					gaePermissionBean.setSubjectOwnerId(userId);
					newAcl.add(gaePermissionBean);					
				}
			}
			pm=getPm();
			try {
				pm.makePersistentAll(newAcl);
				countCache.remove(GaePermissionBean.class);				
			} finally {
				pm.close();
			}
			
			// email: send email about sharing
			// TODO IMPROVEMENT send all emails in GAE persistence asynchronously (task that gets objects and sends them)
			if(userKeysToEmail.size()>0 && userKey!=null) {
				GrowBean grow = getGrow(growId, userId);
				GaeUserBean fromUser = getUserById(userId);
				if(grow!=null) {
					Iterator<Key> iterator = userKeysToEmail.iterator();
					List<EmailBean> emails=new ArrayList<EmailBean>();
					while (iterator.hasNext()) {
						Key toKey = (Key) iterator.next();
						GaeUserBean toUser = getUserBeanByKey(toKey);
						if(toUser!=null) {
							EmailBean email=new EmailBean();
							email.toEmail=toUser.getEmail().getEmail();
							email.toNickname=toUser.getNickname();
							email.subject=fromUser.getNickname()+" shared with you '"+grow.getName()+"' on MindForger...";
							email.body=
								"Hi "+toUser.getNickname()+"!\n" +
								"\n"+
					            fromUser.getNickname()+" shared with you goal '"+grow.getName()+"'. If you want to check goal details, please log in to MindForger and open 'Shared Goals':\n"+
					            "\n"+
					            "  http://web.mindforger.com\n"+
					            "\n"+
					            "Thanks,\n"+
					            "    MindForger\n\n";		
							emails.add(email);
						}
					}	
					Emailing.sendEmails(emails.toArray(new EmailBean[emails.size()]));												
				}
			}
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code, limits
	 * Limits:
	 *   # grows limit checked
	 */
	public String newGrow(String userId) {
		LOG.log(Level.INFO,"newGrow()");
		
		String limitExceededMessage=securityCheckGrowLimit(userId, getUserLimits(userId));
		if(limitExceededMessage!=null) {
			return limitExceededMessage;
		} else {
			GrowBean result;
			result=new GrowBean();
			result.setName(Messages.getString("Persistence.newGoalName"));
			final Date timestamp = new Date();
			result.setModified(timestamp);
			result.setModifiedPretty(Utils.getPrettyTimestampHtml(timestamp.getTime()));

			result = saveGrow(result, userId);

			ownerCache.putOwner(result.getKey(), userId);
			
			return result.getKey();			
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public GrowBean saveGrow(GrowBean bean, String userId) {
		LOG.log(Level.INFO,"saveGrow() "+bean.toString());
				
		boolean create=bean.getKey()==null;

		GaeGrowBean gaeResult;
		GaeUserBean userBean = getUserById(userId);

		PersistenceManager pm=getPm();
		try {			
			if(!create) {
				Key key = Utils.stringToKey(bean.getKey());
				gaeResult = pm.getObjectById(GaeGrowBean.class, key);
				if(!userId.equals(gaeResult.getOwnerId())) {
					throw new MindForgerSecurityException(Messages.getString("error.insufficientModifyGrow"));
				}
			} else {
				gaeResult=new GaeGrowBean(Utils.keyToString(userBean.getKey()));
				gaeResult.setOwnerId(userId);
			}
			gaeResult.fromPojo(bean,Utils.keyToString(userBean.getKey()));
			gaeResult.setModified(new Date());
			gaeResult = (GaeGrowBean)pm.makePersistent(gaeResult);
			countCache.remove(GaeGrowBean.class);				
		} finally {
			pm.close();
		}
		String newGrowKey = Utils.keyToString(gaeResult.getKey());
			
		// questions: load all the questions of this grow, iterate them and split according to type/missing/updated
		List<QuestionAnswerBean> newQuestions=new ArrayList<QuestionAnswerBean>();
		newQuestions.addAll(bean.getG().getQuestions());
		newQuestions.addAll(bean.getR().getQuestions());
		newQuestions.addAll(bean.getO().getQuestions());
		newQuestions.addAll(bean.getW().getQuestions());
		newQuestions.addAll(bean.getI().getQuestions());
		Map<String,QuestionAnswerBean> newMap=new HashMap<String,QuestionAnswerBean>(); 
		for (int i = 0; i < newQuestions.size(); i++) {
			newQuestions.get(i).setGrowKey(newGrowKey);
			newMap.put(newQuestions.get(i).getKey(),newQuestions.get(i));
		}
		
		List<GaeQuestionAnswerBean> oldQuestions=null;
		pm=getPm();
		try {
			Query query=pm.newQuery(GaeQuestionAnswerBean.class);
			query.setFilter("growKey == brandNewGrowKey && ownerId == userId");
			query.declareParameters("String brandNewGrowKey, String userId");
			LOG.log(Level.INFO,"Query: "+query);
			oldQuestions = (List<GaeQuestionAnswerBean>)query.execute(newGrowKey, userId);
			LOG.log(Level.INFO,"  Old questions: "+oldQuestions.size());		
			
			// find questions that are in datastore, but not present among new questions and delete them
			List<GaeQuestionAnswerBean> gaeQuestionsToDelete=new ArrayList<GaeQuestionAnswerBean>();
			if(!oldQuestions.isEmpty()) {
				for (int i = 0; i < oldQuestions.size(); i++) {
					GaeQuestionAnswerBean gaeQuestionBean = oldQuestions.get(i);
					if(!newMap.containsKey(Utils.keyToString(gaeQuestionBean.getKey()))) {
						LOG.log(Level.INFO,"Deleting question: "+gaeQuestionBean.getKey());
						gaeQuestionsToDelete.add(gaeQuestionBean);
						
						fts.delete(MindForgerResourceType.QUESTION, Utils.keyToString(gaeQuestionBean.getKey()), userId);
					}
				}
			}

			pm.deletePersistentAll(gaeQuestionsToDelete);
			countCache.remove(GaeQuestionAnswerBean.class);
			
			// TODO Questions comments should be deleted as well. For now they are deleted they remain in the repository 
			//      and they are deleted with the delete of the grow when all comments associated with the grow are removed.
		} finally {
			pm.close();
		}

		// update/create new questions
		List<GaeQuestionAnswerBean> gaeQuestionsToSave=new ArrayList<GaeQuestionAnswerBean>();
		pm=getPm();
		try {			
			for (int i = 0; i < newQuestions.size(); i++) {
				GaeQuestionAnswerBean gaeQuestionBean;
				if(newQuestions.get(i).getKey()==null) {
					// create
					gaeQuestionBean = new GaeQuestionAnswerBean();
					gaeQuestionBean.setOwnerId(userId);
					gaeQuestionBean.setGrowType(newQuestions.get(i).getGrowType());
				} else {
					// update
					gaeQuestionBean= pm.getObjectById(GaeQuestionAnswerBean.class, Utils.stringToKey(newQuestions.get(i).getKey()));
				}
				gaeQuestionBean.fromPojo(newQuestions.get(i));
				gaeQuestionsToSave.add(gaeQuestionBean);
				LOG.log(Level.INFO,"Storing question: "+i);
			}
		} finally {
			pm.close();
		}

		if(gaeQuestionsToSave.size()>0) {
			pm=getPm();		
			try {			
				pm.makePersistentAll(gaeQuestionsToSave);
				countCache.remove(GaeQuestionAnswerBean.class);				
				LOG.log(Level.INFO,"  Stored: "+gaeResult.toString());
				
				fts.add(gaeQuestionsToSave, bean.getKey(), Locale.US, userId);
			} finally {
				pm.close();
			}			
		}
				
		final GrowBean pojoResult = gaeResult.toPojo();
		pojoResult.setModifiedPretty(Utils.getPrettyTimestampHtml(gaeResult.getModified().getTime()));
				
		return pojoResult;
	}

	/*
	 * Security:
	 * 	user ID set my trusted code; GROW owner verified
	 * Limits:
	 *  N/A
	 */
	public void deleteGrow(GrowBean bean, String userId) {
		LOG.log(Level.INFO,"deleteGrow() "+bean.toString());
		
		String key=bean.getKey();
		
		PersistenceManager pm=getPm();
		// delete grow
		try {
			GaeGrowBean result = pm.getObjectById(GaeGrowBean.class, Utils.stringToKey(key));
			if(userId.equals(result.getOwnerId())) {
				pm.deletePersistent(result);
				countCache.remove(GaeGrowBean.class);
				LOG.log(Level.INFO,"  Grow deleted!");
				
				fts.delete(MindForgerResourceType.GROW, key, userId);
			} else {
				throw new MindForgerSecurityException(Messages.getString("error.insufficientRemoveGrowPermissions"));
			}
		} finally {
			pm.close();
		}
		
		// delete questions
		pm=getPm();
		try {
			// "SELECT FROM " + GaeQuestionAnswerBean.class.getName() + " WHERE growKey == '"+growKey+"' && ownerId == '"+userId+"'";
			Query query=pm.newQuery(GaeQuestionAnswerBean.class);
			query.setFilter("growKey == key && ownerId == userId");
			query.declareParameters("String key, String userId");
			LOG.log(Level.INFO,"Query: "+query);
			long deleted=query.deletePersistentAll(key,userId);
			LOG.log(Level.INFO,"  Grow questions deleted: "+deleted);
			
			// TODO delete questions from FTS 
		} finally {
			pm.close();
		}
		
		// delete comments
		pm=getPm();
		try {
			// "SELECT FROM " + GaeCommentBean.class.getName() + " WHERE growKey == '"+key+"'";
			Query query=pm.newQuery(GaeCommentBean.class);
			query.setFilter("growKey == key");
			query.declareParameters("String key");
			long deleted=query.deletePersistentAll(key);
			LOG.log(Level.INFO,"  Grow question comments to deleted: "+deleted);		
		} finally {
			pm.close();
		}
		
		// delete checklist answers
		pm=getPm();
		try {
			// SELECT FROM " + GaeCheckListAnswerBean.class.getName() + " WHERE growKey == '"+key+"' && ownerId == '"+userId+"'";
			Query query=pm.newQuery(GaeCheckListAnswerBean.class);
			query.setFilter("growKey == key && ownerId == userId");
			query.declareParameters("String key, String userId");
			LOG.log(Level.INFO,"Query: "+query);
			long deleted=query.deletePersistentAll(key,userId);
			LOG.log(Level.INFO,"  Grow checklist answers deleted: "+deleted);		
		} finally {
			pm.close();
		}
		
		// delete permissions
		pm=getPm();
		try {
			// "SELECT FROM " + GaePermissionBean.class.getName() + " WHERE subjectKey == '"+key+"'";
			Query query=pm.newQuery(GaePermissionBean.class);
			query.setFilter("subjectKey == key");
			query.declareParameters("String key");
			LOG.log(Level.INFO,"Query: "+query);
			long deleted=query.deletePersistentAll(key);
			LOG.log(Level.INFO,"  Grow permissions deleted: "+deleted);		
		} finally {
			pm.close();
		}
	}	

	/*
	 * Security:
	 *   user ID set by trusted code
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public LabelBean[] getLabels(String userId) {
		LOG.log(Level.INFO,"getLabels()");

		List<LabelBean> labelsList=null;
		final PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + LabelBean.class.getName() + " WHERE ownerId == '"+userId+"'";
			Query query=pm.newQuery(LabelBean.class);
			query.setFilter("ownerId == userId");
			query.declareParameters("String userID");
			LOG.log(Level.INFO,"Query: "+query);
			labelsList = (List<LabelBean>)query.execute(userId);
			LOG.log(Level.INFO,"  Result: "+labelsList.size());
		} finally {
			pm.close();
		}
		
		if (labelsList==null || labelsList.isEmpty()) {
			return null;
		} else {
			return labelsList.toArray(new LabelBean[labelsList.size()]);
		}									
	}

	@SuppressWarnings("unchecked")
	@Deprecated
	public QuestionSetsBean getQuestionSets(String userId) {
		List<GaeQuestionBean> questions=null;
		PersistenceManager pm=getPm();
		try {
			// "SELECT FROM " + GaeQuestionBean.class.getName() + " WHERE ownerId == '"+userId+"'";
			Query query=pm.newQuery(GaeQuestionBean.class);
			query.setFilter("ownerId == userId");
			query.declareParameters("String userID");
			LOG.log(Level.INFO,"Query: "+query);
			questions = (List<GaeQuestionBean>)query.execute(userId);
			LOG.log(Level.INFO,"  User's questions set size: "+questions.size());
		} finally {
			pm.close();
		}
		ArrayList<String> g=new ArrayList<String>();
		ArrayList<String> r=new ArrayList<String>();
		ArrayList<String> o=new ArrayList<String>();
		ArrayList<String> w=new ArrayList<String>();
		ArrayList<String> i=new ArrayList<String>();
		if(questions!=null && questions.size()>0) {
			for (int j = 0; j < questions.size(); j++) {
				GaeQuestionBean gaeQuestionBean = questions.get(j);
				if(QuestionAnswerBean.G_PART.equals(gaeQuestionBean.getGrowType())) {
					g.add(gaeQuestionBean.getQuestion());
				} else {
					if(QuestionAnswerBean.R_PART.equals(gaeQuestionBean.getGrowType())) {
						r.add(gaeQuestionBean.getQuestion());
					} else {
						if(QuestionAnswerBean.O_PART.equals(gaeQuestionBean.getGrowType())) {
							o.add(gaeQuestionBean.getQuestion());
						} else {
							if(QuestionAnswerBean.W_PART.equals(gaeQuestionBean.getGrowType())) {
								w.add(gaeQuestionBean.getQuestion());
							} else {
								if(QuestionAnswerBean.I_PART.equals(gaeQuestionBean.getGrowType())) {
									i.add(gaeQuestionBean.getQuestion());
								} else {
									LOG.severe("Error: question has unknow GROW type - "+gaeQuestionBean.getGrowType()+" / "+gaeQuestionBean.getKey());
								}
							}
						}
					}
				}
			}
		}

		QuestionSetsBean result=new QuestionSetsBean();
		result.setG(g.toArray(new String[g.size()]));
		result.setR(r.toArray(new String[r.size()]));
		result.setO(o.toArray(new String[o.size()]));
		result.setW(w.toArray(new String[w.size()]));
		result.setI(i.toArray(new String[i.size()]));
		
		result.setgLabels(QuestionsRepository.gLabels);
		result.setrLabels(QuestionsRepository.rLabels);
		result.setoLabels(QuestionsRepository.oLabels);
		result.setwLabels(QuestionsRepository.wLabels);
		result.setiLabels(QuestionsRepository.iLabels);
		
		return result;
	}
	
	/*
	 * Security:
	 *   user ID set by trusted code
	 * Limits:
	 *   N/A
	 */
	public String getNickname(String userId) {
		GaeUserBean user = getUserById(userId);
		return (user==null?"":user.getNickname());
	}

	/*
	 * Security:
	 *   user ID set by trusted code; write permission checked
	 * Limits:
	 *   N/A
	 */
	public void setNickname(String inUserId, String nickname) {
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaeUserBean.class.getName() + " WHERE userId == '"+userId+"'";
			Query query = pm.newQuery(GaeUserBean.class);
			query.setFilter("userId == inUserId");
			query.declareParameters("String inUserId");
			LOG.log(Level.INFO,"Query: "+query);
			@SuppressWarnings("unchecked")
			List<GaeUserBean> usersList=(List<GaeUserBean>)query.execute(inUserId);
			LOG.log(Level.INFO,"  Result: "+usersList.size());
			if(usersList!=null && usersList.size()>0) {
				GaeUserBean gaeUserBean = usersList.get(0);
				if(!inUserId.equals(gaeUserBean.getUserId())) {
					throw new MindForgerSecurityException(Messages.getString("error.insufficientModifyNickname"));
				}				
				gaeUserBean.setNickname(nickname);
				pm.makePersistent(gaeUserBean);
				countCache.remove(GaeUserBean.class);				
			}
		} finally {
			pm.close();
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code; delegates; show profile only if they are friends
	 * Limits:
	 *   N/A
	 */
	public UserProfileBean getUserProfile(String userId, String profileId) {
		if(profileId!=null) {			
			Map<String, FriendBean> friends = getFriends(userId);
			if(friends.containsKey(profileId) || userId.equals(profileId)) {
				// SECURITY: show profile only if they are friends
				UserProfileBean result=new UserProfileBean();
				if(userId.equals(profileId)) {
					GaeUserBean gaeUserBean = getUserById(userId);
					result.setUser(gaeUserBean.toPojo());
				} else {
					result.setUser(friends.get(profileId).getFriend());
				}

				// find profile's friends
				friends = getFriends(profileId, true);
				FriendBean[] f = friends.values().toArray(new FriendBean[friends.size()]);
				if(f!=null) {
					ArrayList<UserBean> resultFriends=new ArrayList<UserBean>();
					for (int j = 0; j < f.length; j++) {
						resultFriends.add(f[j].getFriend());
					}
					result.setFriends(resultFriends.toArray(new UserBean[resultFriends.size()]));
				}

				// find user's goals 						
				GrowBean[] grows = getGrows(profileId);
				if(grows!=null) {
					List<DescriptorBean> growDescriptors=new ArrayList<DescriptorBean>();
					for (int j = 0; j < grows.length; j++) {
						if(securityIsGrowVisibleToUser(grows[j], profileId, userId)) {
							DescriptorBean e = new DescriptorBean();
							e.setType(MindForgerResourceType.GROW);
							e.setId(grows[j].getKey());
							e.setName(grows[j].getName());
							e.setDescription(grows[j].getDescription());
							e.setModified(grows[j].getModified());
							growDescriptors.add(e);
						}
					}
					result.setGrowDescriptors(growDescriptors.toArray(new DescriptorBean[growDescriptors.size()]));
				}						
				return result;
			}
		}
		return null;
	}

	/*
	 * Security:
	 *   user ID set by trusted code; grow permission checked
	 * Limits:
	 *   N/A
	 */
	public CheckListAnswerBean[] getCheckListAnswers(String userId, String inGrowKey, String inMode) {
		// security
		PersistenceManager pm;
		pm = getPm();
		GrowBean growBean=null;
		try {
			growBean = hasPermissionGrow(inGrowKey, userId, pm);
		} finally {
			pm.close();
		}
		String inOwnerId;
		if(CheckListAnswerBean.FAKE_GROW_ID_WHEEL_OF_LIFE.equals(inGrowKey)) {
			inOwnerId=userId;
		} else {
			inOwnerId=growBean.getOwnerId();
		}

		// method
		pm = getPm();
		CheckListAnswerBean[] result=null;
		try {
			// "SELECT FROM " + GaeCheckListAnswerBean.class.getName()+" WHERE ownerId == '"+ownerId+"' && growKey == '"+growKey+"' && mode == '"+mode+"'";
			Query query = pm.newQuery(GaeCheckListAnswerBean.class);
			query.setFilter("ownerId == inOwnerId && growKey == inGrowKey && mode == inMode");
			query.declareParameters("String inOwnerId, String inGrowKey, String inMode");
			LOG.log(Level.INFO,"Query: "+query);
			@SuppressWarnings("unchecked")
			List<GaeCheckListAnswerBean> answersList=(List<GaeCheckListAnswerBean>)query.execute(inOwnerId, inGrowKey, inMode);
			if(answersList!=null && answersList.size()>0) {
				result=new CheckListAnswerBean[answersList.size()];
				for (int i = 0; i < result.length; i++) {
					result[i]=answersList.get(i).toPojo();
				}
			}
		} finally {
			pm.close();
		}
		return result;
	}

	/*
	 * Security:
	 *   user ID set by trusted code; ownership checked
	 * Limits:
	 *   no limit check - there should be limited number of questions > answers
	 */
	public void saveCheckListAnswer(String userId, String inGrowKey, String inMode, Integer questionId, String answer) {
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaeCheckListAnswerBean.class.getName() + " WHERE growKey == '"+inGrowKey+"' && ownerId == '"+userId+"' && questionId == "+questionId.intValue()+"";
			Query query = pm.newQuery(GaeCheckListAnswerBean.class);
			int inQuestionId=questionId.intValue();
			query.setFilter("growKey == inGrowKey && ownerId == userId && questionId == inQuestionId");
			query.declareParameters("String inGrowKey, String userId, int inQuestionId");
			LOG.log(Level.INFO,"Query: "+query);
			@SuppressWarnings("unchecked")
			List<GaeCheckListAnswerBean> checkListAnswers=(List<GaeCheckListAnswerBean>)query.execute(inGrowKey, userId, inQuestionId);
			GaeCheckListAnswerBean gaeCheckListAnswerBean;
			if(!checkListAnswers.isEmpty()) {
				gaeCheckListAnswerBean = checkListAnswers.get(0);
				if(!userId.equals(gaeCheckListAnswerBean.getOwnerId())) {
					throw new MindForgerSecurityException(Messages.getString("error.insufficientModifyChecklist"));
				}
				gaeCheckListAnswerBean.setAnswer((answer==null?null:new Text(answer)));
			} else {
				gaeCheckListAnswerBean=new GaeCheckListAnswerBean();
				gaeCheckListAnswerBean.setOwnerId(userId);
				gaeCheckListAnswerBean.setGrowKey(inGrowKey);
				gaeCheckListAnswerBean.setQuestionId(questionId);
				gaeCheckListAnswerBean.setMode(inMode);
				gaeCheckListAnswerBean.setAnswer((answer==null?null:new Text(answer)));
			}
			pm.makePersistent(gaeCheckListAnswerBean);
			countCache.remove(GaeCheckListAnswerBean.class);				
		} finally {
			pm.close();
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code; ownership checked
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public QuestionAnswerBean[] getActions(String userId) {		
		List<QuestionAnswerBean> result=new ArrayList<QuestionAnswerBean>();
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaeQuestionAnswerBean.class.getName() + " WHERE ownerId == '"+userId+"' && questionLabel == 'Action' && progress != 100";
			Query query = pm.newQuery(GaeQuestionAnswerBean.class);
		    query.setFilter("ownerId == userId && questionLabel == 'Action' && progress != 100");
		    query.declareParameters("String userId");
			List<GaeQuestionAnswerBean> answersList = (List<GaeQuestionAnswerBean>)query.execute(userId);
			if(answersList!=null && answersList.size()>0) {
				for (int i = 0; i < answersList.size(); i++) {
					result.add(answersList.get(i).toPojo());
				}
			}

			// "SELECT FROM " + GaeQuestionAnswerBean.class.getName() + " WHERE ownerId == '"+userId+"' && questionLabel == 'Task' && progress != 100";
			query = pm.newQuery(GaeQuestionAnswerBean.class);
		    query.setFilter("ownerId == userId && questionLabel == 'Task' && progress != 100");
		    query.declareParameters("String userId");
			answersList = (List<GaeQuestionAnswerBean>)query.execute(userId);
			if(answersList!=null && answersList.size()>0) {
				for (int i = 0; i < answersList.size(); i++) {
					result.add(answersList.get(i).toPojo());
				}
			}
		} finally {
			pm.close();
		}
		
		return result.toArray(new QuestionAnswerBean[result.size()]);
	}

	/*
	 * Security:
	 *   user ID set by trusted code; ownership checked
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public QuestionAnswerBean[] getLessonsLearned(String userId) {
		List<QuestionAnswerBean> result=new ArrayList<QuestionAnswerBean>();
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaeQuestionAnswerBean.class.getName() + " WHERE ownerId == '"+userId+"' && questionLabel == 'Lesson'";
			Query query = pm.newQuery(GaeQuestionAnswerBean.class);
			query.setFilter("ownerId == userId && questionLabel == 'Lesson'");
			query.declareParameters("String userId");
			List<GaeQuestionAnswerBean> answersList=null;
			answersList = (List<GaeQuestionAnswerBean>)query.execute(userId);
			if(answersList!=null && answersList.size()>0) {
				for (int i = 0; i < answersList.size(); i++) {
					result.add(answersList.get(i).toPojo());
				}
			}
		} finally {
			pm.close();
		}
		
		return result.toArray(new QuestionAnswerBean[result.size()]);
	}

	/*
	 * Security:
	 *   user ID set by trusted code; ownership checked
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public void setLifeVision(String userId, String lifeVision) {
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaeLifeVisionBean.class.getName() + " WHERE ownerId == '"+userId+"'";
			Query query=pm.newQuery(GaeLifeVisionBean.class);
			query.setFilter("ownerId == userId");
			query.declareParameters("String userId");
			LOG.log(Level.INFO,"Query: "+query);
			List<GaeLifeVisionBean> visionsList = (List<GaeLifeVisionBean>)query.execute(userId);
			LOG.log(Level.INFO,"  Result: "+visionsList.size());
			GaeLifeVisionBean gaeLifeVisionBean;
			if(visionsList!=null && visionsList.size()>0) {
				gaeLifeVisionBean = visionsList.get(0);
				if(!userId.equals(gaeLifeVisionBean.getOwnerId())) {
					throw new MindForgerSecurityException(Messages.getString("error.insufficientModifyGrow"));
				}
			} else {
				gaeLifeVisionBean=new GaeLifeVisionBean();
			}
			gaeLifeVisionBean.setOwnerId(userId);
			gaeLifeVisionBean.setLifeVision((lifeVision==null?null:new Text(lifeVision)));
			pm.makePersistent(gaeLifeVisionBean);
			countCache.remove(GaeLifeVisionBean.class);				
		} finally {
			pm.close();
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public String getLifeVision(String userId) {
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaeLifeVisionBean.class.getName() + " WHERE ownerId == '"+userId+"'";
			Query query=pm.newQuery(GaeLifeVisionBean.class);
			query.setFilter("ownerId == userId");
			query.declareParameters("String userId");
			LOG.log(Level.INFO,"Query: "+query);
			List<GaeLifeVisionBean> visionsList=(List<GaeLifeVisionBean>)query.execute(userId);
			LOG.log(Level.INFO,"  Result: "+visionsList.size());
			if(visionsList!=null && visionsList.size()>0) {
				Text lifeVision = visionsList.get(0).getLifeVision();
				return (lifeVision==null?null:lifeVision.getValue());
			}
		} finally {
			pm.close();
		}
		return "";
	}
	
	/*
	 * Security:
	 *   user ID set by trusted code; ownership checked
	 * Limits:
	 *   N/A
	 */
	public void setUserDescription(String inUserId, String description) {
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaeUserBean.class.getName() + " WHERE userId == '"+userId+"'";
			Query query=pm.newQuery(GaeUserBean.class);
			query.setFilter("userId == inUserId");
			query.declareParameters("String inUserId");
			LOG.log(Level.INFO,"Query: "+query);
			@SuppressWarnings("unchecked")
			List<GaeUserBean> usersList=(List<GaeUserBean>)query.execute(inUserId);
			LOG.log(Level.INFO,"  Result: "+usersList.size());
			if(usersList!=null && usersList.size()>0) {
				GaeUserBean gaeUserBean = usersList.get(0);
				if(!inUserId.equals(gaeUserBean.getUserId())) {
					throw new MindForgerSecurityException(Messages.getString("error.insufficientModifyNickname"));
				}				
				gaeUserBean.setDescription(description);
				pm.makePersistent(gaeUserBean);
				countCache.remove(GaeUserBean.class);				
			}
		} finally {
			pm.close();
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code; ownership checked
	 * Limits:
	 *   N/A
	 */
	public void setUserWeb(String inUserId, String web) {
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaeUserBean.class.getName() + " WHERE userId == '"+userId+"'";
			Query query=pm.newQuery(GaeUserBean.class);
			query.setFilter("userId == inUserId");
			query.declareParameters("String inUserId");
			LOG.log(Level.INFO,"Query: "+query);
			@SuppressWarnings("unchecked")
			List<GaeUserBean> usersList=(List<GaeUserBean>)query.execute(inUserId);
			LOG.log(Level.INFO,"  Result: "+usersList.size());
			if(usersList!=null && usersList.size()>0) {
				GaeUserBean gaeUserBean = usersList.get(0);
				if(!inUserId.equals(gaeUserBean.getUserId())) {
					throw new MindForgerSecurityException(Messages.getString("error.insufficientModifyNickname"));
				}				
				gaeUserBean.setWeb(web);
				pm.makePersistent(gaeUserBean);
				countCache.remove(GaeUserBean.class);				
			}
		} finally {
			pm.close();
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code; ownership checked
	 * Limits:
	 *   checked that user didn't comment too many times for this question
	 */	
	/*
	 * TODO Limit: comment length (bigtable)
	 * TODO Security: check that user has rights to see the GROW 
	 */
	public String saveQuestionComment(String userId, String questionId, String comment) {		
		String result=null;
		if(questionId!=null) {
			String growKey=null;
			GaeUserBean user = getUserById(userId);
			GaeQuestionAnswerBean questionAnswer;
			PersistenceManager pm = getPm();
			try {
				final Key questionKey = Utils.stringToKey(questionId);
				questionAnswer = pm.getObjectById(GaeQuestionAnswerBean.class, questionKey);
				if(questionAnswer!=null) {
					growKey=questionAnswer.getGrowKey();
					
					securityCheckAnswerCommentsLimit(Utils.keyToString(user.getKey()), Utils.keyToString(questionKey));
					
					GaeCommentBean gaeCommentBean = new GaeCommentBean(
							null, 
							Utils.keyToString(user.getKey()), 
							Utils.keyToString(questionKey), 
							growKey, 
							new Date(), 
							comment);
					pm.makePersistent(gaeCommentBean);
					countCache.remove(GaeCommentBean.class);				
					result=Utils.keyToString(gaeCommentBean.getKey());
				} else {
					throw new RuntimeException("Question to which should be added new comment was not found!");
				}
			} finally {
				pm.close();
			}
			
			if(result!=null && questionAnswer!=null && growKey!=null) {
				GaeUserBean commentAuthor=user;				
				String ownerId=questionAnswer.getOwnerId();
				GaeUserBean owner = getUserById(ownerId);
				GrowBean grow = getGrow(growKey, userId);
				if(grow!=null) {
					Emailing.notifyOwnerThatSomebodyCommentedQuestion(
							owner.getNickname(), 
							owner.getEmail().getEmail(),
							commentAuthor.getNickname(),
							grow.getName(),
							comment);
				}
			}
			
		} else {
			throw new MindForgerSecurityException(Messages.getString("error.cannotSaveCommentNoIdentifier"));
		}
				
		return result;
	}	

	/*
	 * Security:
	 *   user ID set by trusted code; checked that user has permissions to at least view the GROW
	 * Limits:
	 *   N/A
	 */	
	public CommentBean[] getCommentsForGrow(String userId, String growId) {
		PersistenceManager pm = getPm();
		try {
			hasPermissionGrow(growId, userId, pm);			
		}  finally {
			pm.close();
		}
		
		List<CommentBean> result=new ArrayList<CommentBean>();
		pm = getPm();
		try {
			// "SELECT FROM " + GaeCommentBean.class.getName() + " WHERE growKey == '"+growId+"'";
			Query query=pm.newQuery(GaeCommentBean.class);
			query.setFilter("growKey == growId");
			query.declareParameters("String growId");
			LOG.log(Level.INFO,"Query: "+query);
			@SuppressWarnings("unchecked")
			List<GaeCommentBean> commentsList=(List<GaeCommentBean>)query.execute(growId);
			LOG.log(Level.INFO,"  Result: "+commentsList.size());
			if(commentsList!=null && commentsList.size()>0) {
				for (int i = 0; i < commentsList.size(); i++) {
					GaeCommentBean commentBean = commentsList.get(i);
					GaeUserBean gaeUserBean = getUserBeanByKey(commentBean.getAuthorUserKey());
					UserBean userPojo = gaeUserBean.toPojo();
					CommentBean resultBean = new CommentBean(
							Utils.keyToString(commentBean.getKey()),
							userPojo,
							commentBean.getQuestionKey(),
							commentBean.getComment(),
							commentBean.getCreated());
					result.add(resultBean);
				}
			}
		} finally {
			pm.close();
		}
		return result.toArray(new CommentBean[result.size()]);
	}

	/*
	 * Security:
	 *   user ID set by trusted code; checked that the user is either comment author or GROW owner
	 * Limits:
	 *   N/A
	 */	
	public void deleteComment(String userId, String commentId) {
		PersistenceManager pm=getPm();
		try {
			GaeCommentBean comment = pm.getObjectById(GaeCommentBean.class,commentId);
			GaeUserBean author = getUserBeanByKey(comment.getAuthorUserKey());
			
			// security
			if(!userId.equals(author.getUserId())) {
				GaeGrowBean grow = pm.getObjectById(GaeGrowBean.class,comment.getGrowKey());
				if(!userId.equals(grow.getOwnerId())) {
					throw new MindForgerSecurityException(Messages.getString("error.insufficientRemoveCommentPermissions"));
				}				
			}

			pm.deletePersistent(comment);
			countCache.remove(GaeCommentBean.class);
		} finally {
			pm.close();
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code; GROW ownership checked
	 * Limits:
	 *   N/A
	 */	
	/*
	 * TODO Limits: check questions limits.
	 */
	public String newQuestionAnswer(String userId, String growKey, int order) {
		if(growKey==null) {
			throw new RuntimeException("Unable to save new question - unknown GROW key!");			
		} else {
			checkGrowOwnership(userId, growKey);
			
			PersistenceManager pm=getPm();
			GaeQuestionAnswerBean gaeQuestionBean=null;
			try {			
				gaeQuestionBean = new GaeQuestionAnswerBean();
				gaeQuestionBean.setOwnerId(userId);
				gaeQuestionBean.setGrowKey(growKey);
				gaeQuestionBean.setOrder(order);
				pm.makePersistent(gaeQuestionBean);
				countCache.remove(GaeQuestionAnswerBean.class);				
			} finally {
				pm.close();
			}
			if(gaeQuestionBean.getKey()==null) {
				throw new RuntimeException("Unable to save new question - unknown question key!");
			} else {
				return Utils.keyToString(gaeQuestionBean.getKey());
			}			
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code; GROW ownership checked
	 * Limits:
	 *   N/A
	 */	
	/**
	 * Used to move question/answer to head or tail.
	 */
	public void insertQuestionAnswerAt(String userId, String questionId, int order) {
		if(questionId!=null) {
			GaeQuestionAnswerBean questionAnswer;
			PersistenceManager pm = getPm();
			try {
				Key questionKey = Utils.stringToKey(questionId);
				questionAnswer = pm.getObjectById(GaeQuestionAnswerBean.class, questionKey);
				if(questionAnswer!=null) {
					String growKey=questionAnswer.getGrowKey();
					hasPermissionGrow(growKey, userId, pm);
					
					questionAnswer.setOrder(order);
					pm.makePersistent(questionAnswer);
					countCache.remove(GaeQuestionAnswerBean.class);				
				} else {
					throw new RuntimeException("Questions to be switched were not found!");
				}
			} finally {
				pm.close();
			}
		} else {
			throw new RuntimeException("Unknown question ID!");
		}
	}
	
	/**
	 * Convention: 
	 *   This method is called in a way that question A suppose to be at the top of question B after switch.
	 *   In other words, parameters are ordered and this method just changes order variables and persists the result.
	 *   This convention might be used to fix the order variables if they are the same for both questions.
	 * 
	 * Shifting
	 *   Question is created with order 0, subsequent moves is simply by switching order of A with B,
	 *   the order goes to negative values. The lowest order number is <= to number of questions that
	 *   were in the grow at some point - it cannot be higher :)
	 * 
	 * Security: checked permissions for GROW
	 */
	public void switchQuestionAnswers(String userId, String questionIdA, String questionIdB) {
		if(questionIdA!=null && questionIdB!=null) {
			GaeQuestionAnswerBean questionAnswerA, questionAnswerB;
			PersistenceManager pm = getPm();
			try {
				Key questionKey = Utils.stringToKey(questionIdA);
				questionAnswerA = pm.getObjectById(GaeQuestionAnswerBean.class, questionKey);
				questionKey = Utils.stringToKey(questionIdB);
				questionAnswerB = pm.getObjectById(GaeQuestionAnswerBean.class, questionKey);
				if(questionAnswerA!=null && questionAnswerB!=null) {
					String growKey=questionAnswerA.getGrowKey();
					if(growKey==null || !growKey.equals(questionAnswerB.getGrowKey())) {
						throw new RuntimeException("Questions are not from the same GROW!");						
					}
					hasPermissionGrow(growKey, userId, pm);
					
					int orderA=questionAnswerA.getOrder();
					int orderB=questionAnswerB.getOrder();
					if(orderA==orderB) {
						orderB--;
					}
					questionAnswerA.setOrder(orderB);
					questionAnswerB.setOrder(orderA);
					
					pm.makePersistent(questionAnswerA);
					pm.makePersistent(questionAnswerB);
					// no need to change count
				} else {
					throw new RuntimeException("Questions to be switched were not found!");
				}
			} finally {
				pm.close();
			}
		} else {
			throw new RuntimeException("Unknown question ID!");
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code; growId ownership is checked in setGrowAcl()
	 * Limits:
	 *   N/A
	 */	
	public void setGrowAclToAllConnections(String userId, String growId) {
		LOG.log(Level.INFO,"setGrowAclToAllConnections()");
		Map<String, FriendBean> friends = getFriends(userId, true);
		List<PermissionBean> acl=new ArrayList<PermissionBean>();
		if(friends!=null) {
			Iterator<FriendBean> i = friends.values().iterator();
			while (i.hasNext()) {
				FriendBean friend = (FriendBean)i.next();
				PermissionBean permissionBean 
					= new PermissionBean(growId, userId, friend.getFriend(), PermissionBean.PERMISSION_READ);
				acl.add(permissionBean);
			}
		}
		setGrowAcl(userId, growId, acl.toArray(new PermissionBean[acl.size()]));
	}

	/*
	 * Security:
	 *   user ID set by trusted code; permissions checked
	 * Limits:
	 *   N/A
	 */	
	@SuppressWarnings("unchecked")
	public GrowBean[] getSharedGrows(String inUserId) {
		int growsToReturn=100;

		List<GaeGrowBean> gaeResult=new ArrayList<GaeGrowBean>();
				
		PersistenceManager pm = getPm();
		try {
			// "SELECT FROM " + GaePermissionBean.class.getName() + " WHERE userId == '"+userId+"'";
			Query q = pm.newQuery(GaePermissionBean.class);
			q.setFilter("userId == inUserId");
			q.declareParameters("String inUserId");
			q.setRange(0, growsToReturn);
			List<GaePermissionBean> permissionList = (List<GaePermissionBean>)q.execute(inUserId);
			LOG.log(Level.INFO,"  Result: "+permissionList.size());
			
			if(permissionList.size()>0) {
				for (GaePermissionBean gaePermissionBean : permissionList) {
					GaeGrowBean gaeGrowBean = pm.getObjectById(GaeGrowBean.class,gaePermissionBean.getSubjectKey());
					if(gaeGrowBean!=null && !inUserId.equals(gaeGrowBean.getOwnerId())) {
						gaeResult.add(gaeGrowBean);						
					}
				}				
			}
		} finally {
			pm.close();
		}
		
		growsToReturn=100-gaeResult.size();

		List<GaeGrowBean> publicGrows=null;
		if(growsToReturn>0) {
			pm = getPm();
			try {
				// "SELECT FROM " + GaeGrowBean.class.getName() + " WHERE sharedTo == 'Everybody'";
				Query q = pm.newQuery(GaeGrowBean.class);
				q.setFilter("sharedTo == 'Everybody'");
				q.setRange(0,growsToReturn);
				publicGrows = (List<GaeGrowBean>)q.execute();
				LOG.log(Level.INFO,"  Result: "+publicGrows.size());						
			} finally {
				pm.close();
			}
			if(publicGrows!=null) {
				for (GaeGrowBean gaeGrowBean : publicGrows) {
					if(gaeGrowBean!=null && !inUserId.equals(gaeGrowBean.getOwnerId())) {
						gaeResult.add(gaeGrowBean);						
					}					
				}
			}
		}
		
		List<GrowBean> result=new ArrayList<GrowBean>();
		
		// load user details
		if(!gaeResult.isEmpty()) {
			for (GaeGrowBean gaeGrowBean : gaeResult) {
				if(gaeGrowBean.getOwnerKey()!=null) {
					GaeUserBean userBean = getUserBeanByKey(gaeGrowBean.getOwnerKey());
					GrowBean pojo = gaeGrowBean.toPojo();
					pojo.setOwner(userBean.toPojo());
					result.add(pojo);
				} else {
					throw new MindForgerSecurityException(Messages.getString("error.noOwnerKeyForGrow",new String[]{KeyFactory.keyToString(gaeGrowBean.getKey())}));
				}
			}			
		}			
		
		Collections.sort(result, growModifiedComparator);
		
		return result.toArray(new GrowBean[result.size()]);
	}
	
	/*
	 * Social - not in separate module as it have dependencies both up and down in the hierarchy.
	 */
	
	/*
	 * Security:
	 *   userId set by trusted code; query string checked, read only method
	 * Limits:
	 *   N/A
	 */
	public FriendBean[] findFriend(String userId, String riaQuery) {
		riaQuery=Utils.checkAndEncodeQueryString(riaQuery);
		
		HashMap<String, FriendBean> resultMap=new HashMap<String, FriendBean>();
		PersistenceManager pm=getPm();
		
		// return the first 250 users
		try {
			Query query = pm.newQuery(GaeUserBean.class);
			query.setRange(0,250);
			query.setOrdering("nickname ASC");
			if(!"".equals(riaQuery)) {
				query.setFilter("this.nickname.startsWith(\""+riaQuery+"\")"); // this works ;-)				
				//query.declareParameters("String riaQuery");
				//query.setFilter("this.nickname.startsWith(riaQuery)"); // NPE Right side of expression is of unexpected type:
				//query.setFilter("nickname.matches(\"t?\")"); // * ? % - Wildcard must appear at the end of the expression string (only prefix matches are supported)
			}
			LOG.log(Level.INFO,"Query: "+query.toString());
			@SuppressWarnings("unchecked")
			List<GaeUserBean> users=(List<GaeUserBean>)query.execute(riaQuery);
			
			for (int i = 0; i < users.size(); i++) {
				FriendBean friendBean = new FriendBean();
				friendBean.setFriend(users.get(i).toPojo());
				resultMap.put(friendBean.getFriend().getUserId(), friendBean);
			}
		} finally {
			pm.close();
		}
		
		// filter out users who are already friends
		Map<String, FriendBean> friends = getFriends(userId);
		if(friends!=null) {
			Iterator<FriendBean> iterator = friends.values().iterator();
			while (iterator.hasNext()) {
				FriendBean friendBean = (FriendBean) iterator.next();
				String key = friendBean.getFriend().getUserId();
				if(resultMap.containsKey(key)) {
					resultMap.remove(key);
				}				
			}
		}
		// filter out self
		if(resultMap.containsKey(userId)) {
			resultMap.remove(userId);
		}
		
		return resultMap.values().toArray(new FriendBean[resultMap.size()]);
	}

	/*
	 * Security:
	 *   Requestor identity set by trusted code; anybody can be requested anyway.
	 * Limits:
	 *   Friend requests count checked.
	 */
	public void requestFriendship(String userId, String friendId, String role) {
		securityCheckFriendRequestLimit(userId);

		// TODO consider adding "already requested" check
		
		PersistenceManager pm=getPm();
		Key ownerKey=getKeyForUserId(userId);
		Key friendKey=getKeyForUserId(friendId);
		try {
			GaeFriendBean friendship=new GaeFriendBean();
			friendship.setOwnerId(userId);
			friendship.setOwnerKey(Utils.keyToString(ownerKey));
			friendship.setFriendId(friendId);
			friendship.setFriendKey(Utils.keyToString(friendKey));
			friendship.setFriendRole(role);
			friendship.setConfirmed(false);
			
			pm.makePersistent(friendship);
			countCache.remove(GaeFriendBean.class);				
		} finally {
			pm.close();
		}
		
		GaeUserBean user = getUserBeanByKey(ownerKey);
		GaeUserBean friend = getUserBeanByKey(friendKey);
		String userNickname=user.getNickname();
		if(friend.getEmail()==null) {
			return;
		}
		
		String friendEmail=friend.getEmail().getEmail();
		String friendNickname=friend.getNickname();
		Emailing.requestFriendship(role, friendEmail, friendNickname, userNickname);
	}

	/*
	 * Security:
	 *   private method used internally
	 * Limits:
	 *   N/A
	 */
	private List<GrowBean> getBothFriendsGrows(String userA, String userB) {
		List<GrowBean> growDescriptors=new ArrayList<GrowBean>();
		GrowBean[] growsDescriptorsA = getGrows(userA);
		if(growsDescriptorsA!=null) {
			growDescriptors.addAll(Arrays.asList(growsDescriptorsA));			
		}
		GrowBean[] growsDescriptorsB = getGrows(userB);
		if(growsDescriptorsB!=null) {
			growDescriptors.addAll(Arrays.asList(growsDescriptorsB));			
		}
		return growDescriptors;
	}
	
	/*
	 * Security:
	 *   private method used internally
	 * Limits:
	 *   N/A
	 */
	private void setGrowsAclPermissionsAmongFriends(GaeUserBean userA, GaeUserBean userB) {
		List<GrowBean> growDescriptors = getBothFriendsGrows(userA.getUserId(), userB.getUserId());
		
		if(growDescriptors.size()>0) {
			List<GaePermissionBean> permissionsToAdd=new ArrayList<GaePermissionBean>();
			for(GrowBean growBean : growDescriptors) {				
				if(GrowBean.SHARING_OPTION_VALUE_ALL_CONNECTIONS.equals(growBean.getSharedTo())) {
					if(growBean.getOwnerId().equals(userA.getUserId())) {
						permissionsToAdd.add(new GaePermissionBean(growBean.getKey(), growBean.getOwnerId(), userB.getUserId(), PermissionBean.PERMISSION_READ));
					} else {
						permissionsToAdd.add(new GaePermissionBean(growBean.getKey(), growBean.getOwnerId(), userA.getUserId(), PermissionBean.PERMISSION_READ));					
					}
				}
			}
			
			if(permissionsToAdd.size()>0) {
				LOG.log(Level.INFO,"  Adding permissions: "+permissionsToAdd.size());
				PersistenceManager pm=getPm();
				try {
					pm.makePersistentAll(permissionsToAdd);
					countCache.remove(GaePermissionBean.class);				
				} finally {
					pm.close();
				}									
			}
		}
	}
	
	/*
	 * Security:
	 *   friendId set by trusted code; request existence checked
	 * Limits:
	 *   N/A
	 */
	public void acceptFriendship(String inFriendId, String inOwnerId, String role) {
		PersistenceManager pm=getPm();
		try {
			// "SELECT FROM " + GaeFriendBean.class.getName() + " WHERE ownerId == '"+ownerId+"' && friendId == '"+friendId+"'";
			Query friendsQuery = pm.newQuery(GaeFriendBean.class);
			friendsQuery.setFilter("ownerId == inOwnerId && friendId == inFriendId");
			friendsQuery.declareParameters("String inOwnerId, String inFriendId");
			LOG.log(Level.INFO,"Query: "+friendsQuery);
			@SuppressWarnings("unchecked")
			List<GaeFriendBean> friends=(List<GaeFriendBean>)friendsQuery.execute(inOwnerId, inFriendId);
			
			if(friends!=null && friends.size()>0) {
				GaeFriendBean friend=friends.get(0);
				friend.setConfirmed(true);
				friend.setOwnerRole(role);
				pm.makePersistent(friend);
				countCache.remove(GaeFriendBean.class);				
			} else {
				throw new RuntimeException("No friendship to accept: friend == '"+inFriendId+"' && owner == '"+inOwnerId+"'");
			}
		} finally {
			pm.close();
		}
				
		GaeUserBean friend = getUserById(inFriendId);
		GaeUserBean owner = getUserById(inOwnerId);
		
		setGrowsAclPermissionsAmongFriends(friend, owner);		
		
		String friendNickname=friend.getNickname();
		String ownerNickname=owner.getNickname();
		String ownerEmail=owner.getEmail().getEmail();
		if(ownerEmail!=null) {
			Emailing.friendshipConfirmed(ownerNickname,ownerEmail,friendNickname,role);
		}
	}

	/*
	 * Security:
	 *   user ID set by trusted code; request existence checked
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public void rejectFriendship(String inUserId, String inFriendId) {
		PersistenceManager pm=getPm();
		try {
			// "SELECT FROM " + GaeFriendBean.class.getName() + " WHERE ownerId == '"+inUserId+"' && friendId == '"+inFriendId+"'";
			Query friendsQuery = pm.newQuery(GaeFriendBean.class);
			friendsQuery.setFilter("ownerId == inUserId && friendId == inFriendId");
			friendsQuery.declareParameters("String inUserId, String inFriendId");
			LOG.log(Level.INFO,"Query: "+friendsQuery);
			List<GaeFriendBean> friends=(List<GaeFriendBean>)friendsQuery.execute(inUserId, inFriendId);			
			if(friends!=null && friends.size()>0) {
				pm.deletePersistent(friends.get(0));
				countCache.remove(GaeFriendBean.class);
			}			

			// "SELECT FROM " + GaeFriendBean.class.getName() + " WHERE friendId == '"+inUserId+"' && ownerId == '"+inFriendId+"'";
			friendsQuery = pm.newQuery(GaeFriendBean.class);
			friendsQuery.setFilter("friendId == inUserId && ownerId == inFriendId");
			friendsQuery.declareParameters("String inUserId, String inFriendId");
			LOG.log(Level.INFO,"Query: "+friendsQuery);
			friends= (List<GaeFriendBean>)friendsQuery.execute(inUserId, inFriendId);			
			if(friends!=null && friends.size()>0) {
				pm.deletePersistent(friends.get(0));
				countCache.remove(GaeFriendBean.class);
			}			
		} finally {
			pm.close();
		}
	}

	/*
	 * Security:
	 *   friendId set by trusted code; request existence checked; permissions checked
	 * Limits:
	 *   N/A
	 */
	@SuppressWarnings("unchecked")
	public void revokeFriendship(String inUserId, String inFriendId) {
		LOG.log(Level.INFO,"revokeFriendship()");
		
		rejectFriendship(inUserId, inFriendId);

		// remove permissions for GROWs shared between these connections
		List<GaePermissionBean> permissionsToDelete=new ArrayList<GaePermissionBean>();
		PersistenceManager pm;
		// constant complexity: as permission contains subject owner, I can delete all permissions using one query
		// simply removing all permissions that they granted to each other
		pm = getPm();
		try {
			// "SELECT FROM " + GaePermissionBean.class.getName() + " WHERE subjectOwnerId == '"+inUserId+"' && userId == '"+inFriendId+"'";
			Query query=pm.newQuery(GaePermissionBean.class);
			query.setFilter("subjectOwnerId == inUserId && userId == inFriendId");
			query.declareParameters("String inUserId, String inFriendId");
			LOG.log(Level.INFO,"Query: "+query);
			List<GaePermissionBean> oldPermissions = (List<GaePermissionBean>)query.execute(inUserId, inFriendId);
			if(!oldPermissions.isEmpty()) {
				for (GaePermissionBean gaePermissionBean : oldPermissions) {
					permissionsToDelete.add(gaePermissionBean);
				}
			}
			// "SELECT FROM " + GaePermissionBean.class.getName() + " WHERE userId== '"+inUserId+"' && subjectOwnerId == '"+inFriendId+"'";
			query=pm.newQuery(GaePermissionBean.class);
			query.setFilter("subjectOwnerId == inUserId && subjectOwnerId == inFriendId");
			query.declareParameters("String inUserId, String inFriendId");
			LOG.log(Level.INFO,"Query: "+query);
			oldPermissions = (List<GaePermissionBean>)query.execute(inUserId, inFriendId);
			if(!oldPermissions.isEmpty()) {
				for (GaePermissionBean gaePermissionBean : oldPermissions) {
					permissionsToDelete.add(gaePermissionBean);
				}
			}

			if(permissionsToDelete.size()>0) {
				LOG.log(Level.INFO,"  Deleting permissions: "+permissionsToDelete.size());

				pm.deletePersistentAll(permissionsToDelete);
				countCache.remove(GaePermissionBean.class);
			}
		} finally {
			pm.close();
		}									
	}

	public DescriptorBean[] fulltextSearch(String search, String userId) {
		return fts.find(search, userId);
	}
}
